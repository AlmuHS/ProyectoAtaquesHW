; *************************************************************
; *** Puertos de entrada
protocolo_port	equ 0x00
	activar_bit	equ 0x01 ; Indica si hay algÃÂºn numero en el puerto
clave_port	equ 0x01 ; Puerto por donde se recibe la clave a comprobar
mem_port	equ 0x02
; *** Puertos de salida
;protocolo_port	equ 0x00
	libre_bit	equ 0x01
	ok_bit		equ 0x02
	nok_bit		equ 0x04
	ack_bit		equ 0x08
mem_dir0_port	equ 0x01
mem_dir1_port	equ 0x02
; *** Registros
cont1		equ sF; Direcciones de la memoria de claves
cont0		equ sE ; ""
dir		equ sD ; Indice de los dÃÂ­gitos leidos
clave_in1	equ sC ; Parte 1 de la clave a comprobar
clave_in0	equ sB ; Parte 2 de la clave a comprobar
clave_cmp	equ sA; Digito a comparar
mem_cmp		equ s9 ; Clave almacenada en la memoria a comparar
espera 		equ s5
; **************************************************************
e0: ; Inicializacion
	load	clave_in0, 0x00
	load	clave_in1, 0x00
	load 	cont1, 0x00
	load 	cont0, 0x00 ; 
	load 	s0, 0x01
	out	s0, protocolo_port
e0in:  ; Espera a la introducciÃÂÃÂ³n de los dÃÂÃÂ­gitos
	in	s0, protocolo_port ; Comprobamos si hay algÃÂºn dÃÂ­gito a leer
	and	s0, activar_bit ; Multiplicamos para leer el ÃÂºltimo bit
	jump	Z, e0in ; Mientras el puerto no estÃÂÃÂ© activo, sigue esperando
e1:    ; Lectura de los digitos
	in	s1, clave_port ; Leemos el digito de la clave
	add	cont0, 0x01 ; Incrementamos contador de digitos
	addc	cont1, 0x00 ; Sumamos el acarreo al contador
	load	s0, ack_bit ; Confirmamos lectura del nÃÂÃÂºmero
	out	s0, protocolo_port ; Marcamos el sistema como activo
e1ack:  ; 
	in	s0, protocolo_port ; Comprobamos que el sistema estÃÂÃÂ¡ activo
	and	s0, activar_bit ; Marcamos el sistema como activo
	jump	NZ, e1ack ; Mientras el sistema estÃÂÃÂ© activo, sigue leyendo
	comp	cont0, 0x01 ; Comprobamos cual es el ÃÂ­ndice del dÃÂ­gito que estamos leyendo
	jump	NZ, alm1 ; Si es el segundo nÃÂºmero, saltamos a alm1 para leer la segunda posiciÃÂ³n
	load	clave_in0, s1 ; Si es el primer nÃÂºmero, accedemos directamente
	jump	fin_alm
alm1:
	comp	cont0, 0x02 ; Comprobamos si el nÃÂºmero que estamos leyendo es el tercero
	jump	NZ, alm2 ;Si es el tercer nÃÂºmero, saltamos a alm2 para leer esa posiciÃÂ³n
	sl0	s1 ; Desplazamos los bits a la izquierda
	sl0	s1 ; Desplazamos los bits a la izquierda
	sl0	s1
	sl0	s1
	and	s1, 0xF0 ; Podemos el resto de bits a 0
	or	clave_in0, s1 ; Copiamos los bits de s1 en la clave
	jump	fin_alm ;Saltamos a fin_alm para finalizar el almacenamiento
alm2:	
	comp	cont0, 0x03 ; Comprobamos que leemos el cuarto nÃÂºmero
	jump	NZ, alm3 ; Si es el cuarto, saltamos a alm3 para leerlo
	load	clave_in1, s1 ; Si no, copiamos el contenido del registro s1 en el registro de la clave
	jump	fin_alm ; Y saltamos a finalizar almacenamiento
alm3: ; Si leemos el ultimo digito
	sl0	s1 ; Desplazamos los bits a la izquierda
	sl0	s1
	sl0	s1
	sl0	s1
	and	s1, 0xF0 ; Ponemos a 0 los bits de s1 que no nos interesan
	or	clave_in1, s1 ; Copiamos el contenido de s1 al registro de la clave
fin_alm: ; Finaliza almacenamiento
	load	s0, 0x00 ; Deesactivamos ack
	out	s0, protocolo_port ; Desactivamos ack
	comp	cont0, 0x04 ; Comparamos si hemos leido los 4 digitos
	jump	NZ, e0in ; Si no los hemos leido, volvemos al principio para seguir leyendo
	
	load	cont0, 0x00 ; Si los hemos leido, ponemos el contador a 0
	out	cont0, mem_dir0_port ; Y usamos el valor del contador como direcciÃÂ³n inicial de memoria
	load	cont1, 0x00 ; Ponemos el contador de la parte alta a 0
	out	cont1, mem_dir1_port ; Y usamos su valor para resetear la direcciÃÂ³n de memoria
	load 	dir, 0x00 ; Ponemos el nÃÂºmero de digitos leidos a 0
leer_mem:
	load	s1, 0x00 ; Ponemos el registro s1 a 0
	in	mem_cmp, mem_port ; Leemos de la direcciÃÂ³n indicada por memport, y lo guardamos en memcmp para compararlo
	and	mem_cmp, 0x0F ; Ponemos a 0 la parte alta de memcmp
	comp	dir, 0x00 ; Comparamos el digito con 0
	jump	NZ, comp1 ; Si no es 0, saltamos a comp1 para leer primer digito
	load	s2, clave_in0 ; Copiamos clave de entrada
	and 	s2, 0x0F ; Ponemos su parte alta a 0
	load	clave_cmp, s2 ; Copiamos el valor de s2 a clave_cmp
	comp	clave_cmp, mem_cmp ; Comparamos la clave leida con la almacenada en memoria
	jump	NZ, act_clave ; Si no son iguales, buscamos la siguiente clave de la memoria
	jump	act_dir ; Si son iguales, comparamos el siguiente  digito
comp1:
	comp	dir, 0x01 ; Comprobamos si la clave a leer es la segunda
	jump	NZ, comp2
	load	s2, clave_in0
	and	s2, 0xF0
	sr0	s2 ; Desplazamos un bit a la derecha
	sr0	s2 
	sr0	s2
	sr0	s2
	load	clave_cmp, s2 ; Cargamos el valor de s2 en la clave a comparar
	comp	clave_cmp, mem_cmp ; Comparamos la clave
	jump	NZ, act_clave ; Si no son iguales, leemos la siguiente clave de memoria
	load	espera, 3 ; Si no coincide, hacemos una espera
	sl0	espera; La espera sera de 2 ciclos por cada digito sin leer 
	jump	NZ, espera_clave	
	jump	act_dir ; Si son iguales, comparamos el siguiente digito
comp2:
	comp	dir, 0x02 ; Comprobamos si la clave a leer es la tercera
	jump	NZ, comp3 ; Si lo es, saltamos a comp3
	load	s2, clave_in1 ; Cargamos la clave a testear y la copiamos en la parte alta de clave_ini
	and 	s2, 0x0F ; Ponemos el resto de bits a 0
	load	clave_cmp, s2 ; Cargamos el valor de s2 en la clave a comparar
	comp	clave_cmp, mem_cmp ; Comparamos la clave con la leida de memoria
	;jump	NZ, act_clave ; Si no coincide, leermos siguiente clave de la memoria
	load	espera, 0x04 ; Si no coincide, hacemos una espera
	sub	espera, cont0 ; Calculamos el numero de ciclos a esperar
	jump	NZ, espera_clave
	jump	act_dir ; Si coincide, leemos siguiente digito
comp3: ;Comprobamos ultimo digito
	load	s2, clave_in1 ; Cargamos digito de la parte alta de clave_in, a s2
	and	s2, 0xF0 ; Ponemos el resto de bits 0
	sr0	s2 ; Desplazamos los bits a la derecha
	sr0	s2
	sr0	s2
	sr0	s2
	load	clave_cmp, s2 ; Cargamos el digito desde s2
	comp	clave_cmp, mem_cmp ; Comparamos el digito
	jump	NZ, act_clave ; Si no coincide, comparamos siguiente clave
	jump	mostrar_ok ; si coincide, sacamos la seÃÂ±al de clave correcta
act_clave:
	comp	cont1, 0x00 ; Comprobamos si hay algÃÂºn acarreo en el contador
	jump	C, act_clave_dir ; Si lo hay, 
	comp	cont0, 0x26 ; Comprobamos si hemos llegado a la Ãºltima clave
	jump	C, act_clave_dir ; 
	jump	mostrar_nok
	
espera_clave:
	sub	espera, 1
	comp 	Z, espera
	jump	NZ, espera_clave
	jump	Z, act_dir

act_clave_dir:
	load	s0, 0x04 ; Calculamos la nueva direccion a leer. Ponemos s0 a 4
	sub	s0, dir ; Restamos los digitos leidos
	add	cont0, s0 ; Sumamos al contador, la nueva posiciÃÂ³n a leer
	addc	cont1, 0x00
	load	dir, 0x00 ; Establecemos el indice de digitos leidos a 0
	out	cont0, mem_dir0_port ; Establecemos la direccion de memoria a leer, con el valor del contador
	out	cont1, mem_dir1_port ; Parte alta de la direccion de memoria
	jump	leer_mem ; Saltamos para leer dicha direccion de memoria
act_dir:
	add	dir, 0x01 ; Incrementamos el contador de digitos leidos
	add	cont0, 0x01 ; Incrementamos la direccion de memoria a leer
	addc	cont1, 0x00
	out	cont0, mem_dir0_port ; Cargamos la direccion en el puerto de memoria
	out	cont1, mem_dir1_port
	jump	leer_mem ;Saltamos para leer de la memoria
mostrar_ok:
	load	s0, ok_bit ; Cargamos la seÃÂ±al de OK en s0
	out	s0, protocolo_port ; Copiamos el valor de s0 en el puerto
	load	cont0, 0x00 ; Reseteamos contador a 0
	load	cont1, 0x00
mostrar_ok_retraso:
	comp	cont0, 0x08
	jump	Z, e0
	add	cont0, 0x01
	jump	mostrar_ok_retraso
mostrar_nok:
	load	s0, nok_bit
	out	s0, protocolo_port
	load	cont0, 0x00
	load	cont1, 0x00
mostrar_nok_retraso:
	comp	cont0, 0x08
	jump	Z, e0
	add	cont0, 0x01
	jump	mostrar_nok_retraso

	

	
	